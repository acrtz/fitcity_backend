{"version":3,"sources":["../../src/plugins/PgTypesPlugin.js"],"names":["indent","str","replace","stringType","name","description","serialize","value","String","parseValue","parseLiteral","ast","kind","STRING","Error","parseCache","parseInterval","result","get","Object","freeze","set","pgRangeParser","parse","parts","split","length","start","inclusive","slice","end","inclusivity","true","false","join","PgTypesPlugin","builder","pgExtendedTypes","pgLegacyJsonUuid","hook","build","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","addType","pgSql","sql","inflection","gqlTypeByTypeIdGenerator","gqlInputTypeByTypeIdGenerator","gqlTypeByTypeId","assign","pgGqlTypeByTypeId","gqlInputTypeByTypeId","pgGqlInputTypeByTypeId","pg2GqlMapper","pg2gql","val","type","__isNull","id","map","domainBaseType","isPgArray","Array","isArray","namespaceName","v","arrayItemType","gql2pg","null","unmap","fragment","identifier","makeIntervalFields","seconds","minutes","hours","days","months","years","GQLInterval","fields","GQLIntervalInput","pgTypeById","reduce","memo","BigFloat","BitString","rawTypes","tweakToJson","tweakToText","pgTweaksByTypeId","typeId","categoryLookup","B","N","A","enforceGqlTypeByPgType","arrayItemTypeId","pgTweakFragmentForType","tweaker","error","process","env","NODE_ENV","console","SimpleDate","SimpleDatetime","SimpleTime","SimpleJSON","SimpleUUID","JSONType","UUIDType","DateType","DateTimeType","TimeType","Point","x","y","PointInput","oidLookup","oidInputLookup","identity","_","jsonStringify","o","JSON","stringify","keys","key","push","parseMoney","numerical","lastCommaIndex","lastIndexOf","parseFloat","f","substr","depth","reallyEnforceGqlTypeByPgType","e","message","originalError","gqlType","gqlInputType","enumType","values","enumVariants","enumName","subtype","typeById","rangeSubTypeId","gqlRangeSubType","Range","rangeType","RangeInput","RangeBound","rangeBoundType","RangeBoundInput","inputType","pgRange","parsed","pgParse","indexOf","parseInt","getTypeParser","lower","upper","lowerInclusive","upperInclusive","literal","domainBaseTypeId","baseType","baseInputType","create","domainType","gen","category","getGqlTypeByTypeId","find","t","Type","getGqlInputTypeByTypeId","registerGqlTypeByTypeId","yieldToExisting","registerGqlInputTypeByTypeId","extend","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId"],"mappings":"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","file":"PgTypesPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport {\n  GraphQLNonNull,\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLList,\n  GraphQLEnumType,\n  GraphQLObjectType,\n  GraphQLInputObjectType,\n  GraphQLScalarType,\n  isInputType,\n  getNamedType,\n} from \"graphql\";\nimport { Kind } from \"graphql/language\";\nimport { types as pgTypes } from \"pg\";\n\nimport { GraphQLJSON, GraphQLJson } from \"../GraphQLJSON\";\n\nimport rawParseInterval from \"postgres-interval\";\nimport LRU from \"lru-cache\";\n\nfunction indent(str) {\n  return \"  \" + str.replace(/\\n/g, \"\\n  \");\n}\n\nconst stringType = (name, description) =>\n  new GraphQLScalarType({\n    name,\n    description,\n    serialize: value => String(value),\n    parseValue: value => String(value),\n    parseLiteral: ast => {\n      if (ast.kind !== Kind.STRING) {\n        throw new Error(\"Can only parse string values\");\n      }\n      return ast.value;\n    },\n  });\n/*\nconst {\n  GraphQLDate,\n  GraphQLTime,\n  GraphQLDateTime,\n} = require(\"graphql-iso-date\");\n*/\n\nconst parseCache = LRU(500);\nfunction parseInterval(str) {\n  let result = parseCache.get(str);\n  if (!result) {\n    result = rawParseInterval(str);\n    Object.freeze(result);\n    parseCache.set(str, result);\n  }\n  return result;\n}\n\nconst pgRangeParser = {\n  parse(str) {\n    const parts = str.split(\",\");\n    if (parts.length !== 2) {\n      throw new Error(\"Invalid daterange\");\n    }\n\n    return {\n      start:\n        parts[0].length > 1\n          ? {\n              inclusive: parts[0][0] === \"[\",\n              value: parts[0].slice(1),\n            }\n          : null,\n      end:\n        parts[1].length > 1\n          ? {\n              inclusive: parts[1][parts[1].length - 1] === \"]\",\n              value: parts[1].slice(0, -1),\n            }\n          : null,\n    };\n  },\n\n  serialize({ start, end }) {\n    const inclusivity = {\n      true: \"[]\",\n      false: \"()\",\n    };\n\n    return [\n      start ? inclusivity[start.inclusive][0] + start.value : \"[\",\n      end ? end.value + inclusivity[end.inclusive][1] : \"]\",\n    ].join(\",\");\n  },\n};\n\nexport default (function PgTypesPlugin(\n  builder,\n  { pgExtendedTypes = true, pgLegacyJsonUuid = false }\n) {\n  // XXX: most of this should be in an \"init\" hook, not a \"build\" hook\n  builder.hook(\"build\", build => {\n    const {\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      getTypeByName,\n      addType,\n      pgSql: sql,\n      inflection,\n    } = build;\n\n    const gqlTypeByTypeIdGenerator = {};\n    const gqlInputTypeByTypeIdGenerator = {};\n    const gqlTypeByTypeId = Object.assign({}, build.pgGqlTypeByTypeId);\n    const gqlInputTypeByTypeId = Object.assign(\n      {},\n      build.pgGqlInputTypeByTypeId\n    );\n    const pg2GqlMapper = {};\n    const pg2gql = (val, type) => {\n      if (val == null) {\n        return val;\n      }\n      if (val.__isNull) {\n        return null;\n      }\n      if (pg2GqlMapper[type.id]) {\n        return pg2GqlMapper[type.id].map(val);\n      } else if (type.domainBaseType) {\n        return pg2gql(val, type.domainBaseType);\n      } else if (type.isPgArray) {\n        if (!Array.isArray(val)) {\n          throw new Error(\n            `Expected array when converting PostgreSQL data into GraphQL; failing type: '${\n              type.namespaceName\n            }.${type.name}'`\n          );\n        }\n        return val.map(v => pg2gql(v, type.arrayItemType));\n      } else {\n        return val;\n      }\n    };\n    const gql2pg = (val, type) => {\n      if (val == null) {\n        return sql.null;\n      }\n      if (pg2GqlMapper[type.id]) {\n        return pg2GqlMapper[type.id].unmap(val);\n      } else if (type.domainBaseType) {\n        return gql2pg(val, type.domainBaseType);\n      } else if (type.isPgArray) {\n        if (!Array.isArray(val)) {\n          throw new Error(\n            `Expected array when converting GraphQL data into PostgreSQL data; failing type: '${\n              type.namespaceName\n            }.${type.name}' (type: ${type === null ? \"null\" : typeof type})`\n          );\n        }\n        return sql.fragment`array[${sql.join(\n          val.map(v => gql2pg(v, type.arrayItemType)),\n          \", \"\n        )}]::${sql.identifier(type.namespaceName)}.${sql.identifier(\n          type.name\n        )}`;\n      } else {\n        return sql.value(val);\n      }\n    };\n    /*\n      type =\n        { kind: 'type',\n          id: '1021',\n          name: '_float4',\n          description: null,\n          namespaceId: '11',\n          namespaceName: 'pg_catalog',\n          type: 'b',\n          category: 'A',\n          domainIsNotNull: false,\n          arrayItemTypeId: '700',\n          classId: null,\n          domainBaseTypeId: null,\n          enumVariants: null,\n          rangeSubTypeId: null }\n      */\n\n    const makeIntervalFields = () => {\n      return {\n        seconds: {\n          description:\n            \"A quantity of seconds. This is the only non-integer field, as all the other fields will dump their overflow into a smaller unit of time. Intervals donâ€™t have a smaller unit than seconds.\",\n          type: GraphQLFloat,\n        },\n        minutes: {\n          description: \"A quantity of minutes.\",\n          type: GraphQLInt,\n        },\n        hours: {\n          description: \"A quantity of hours.\",\n          type: GraphQLInt,\n        },\n        days: {\n          description: \"A quantity of days.\",\n          type: GraphQLInt,\n        },\n        months: {\n          description: \"A quantity of months.\",\n          type: GraphQLInt,\n        },\n        years: {\n          description: \"A quantity of years.\",\n          type: GraphQLInt,\n        },\n      };\n    };\n    const GQLInterval = new GraphQLObjectType({\n      name: \"Interval\",\n      description:\n        \"An interval of time that has passed where the smallest distinct unit is a second.\",\n      fields: makeIntervalFields(),\n    });\n    addType(GQLInterval);\n\n    const GQLIntervalInput = new GraphQLInputObjectType({\n      name: \"IntervalInput\",\n      description:\n        \"An interval of time that has passed where the smallest distinct unit is a second.\",\n      fields: makeIntervalFields(),\n    });\n    addType(GQLIntervalInput);\n\n    const pgTypeById = introspectionResultsByKind.type.reduce((memo, type) => {\n      memo[type.id] = type;\n      return memo;\n    }, {});\n\n    const BigFloat = stringType(\n      \"BigFloat\",\n      \"A floating point number that requires more precision than IEEE 754 binary 64\"\n    );\n    const BitString = stringType(\n      \"BitString\",\n      \"A string representing a series of binary bits\"\n    );\n    addType(BigFloat);\n    addType(BitString);\n\n    const rawTypes = [\n      1186, // interval\n      1082, // date\n      1114, // timestamp\n      1184, // timestamptz\n      1083, // time\n      1266, // timetz\n    ];\n\n    const tweakToJson = fragment => fragment; // Since everything is to_json'd now, just pass through\n    const tweakToText = fragment => sql.fragment`(${fragment})::text`;\n    const pgTweaksByTypeId = Object.assign(\n      // ::text rawTypes\n      rawTypes.reduce((memo, typeId) => {\n        memo[typeId] = tweakToText;\n        return memo;\n      }, {}),\n      {\n        // cast numbers above our ken to strings to avoid loss of precision\n        \"20\": tweakToText,\n        \"1700\": tweakToText,\n        // to_json all dates to make them ISO (overrides rawTypes above)\n        \"1082\": tweakToJson,\n        \"1114\": tweakToJson,\n        \"1184\": tweakToJson,\n        \"1083\": tweakToJson,\n        \"1266\": tweakToJson,\n      }\n    );\n\n    const categoryLookup = {\n      B: () => GraphQLBoolean,\n\n      // Numbers may be too large for GraphQL/JS to handle, so stringify by\n      // default.\n      N: type => {\n        pgTweaksByTypeId[type.id] = tweakToText;\n        return BigFloat;\n      },\n\n      A: type =>\n        new GraphQLList(\n          enforceGqlTypeByPgType(pgTypeById[type.arrayItemTypeId])\n        ),\n    };\n\n    const pgTweakFragmentForType = (fragment, type) => {\n      const tweaker = pgTweaksByTypeId[type.id];\n      if (tweaker) {\n        return tweaker(fragment);\n      } else if (type.domainBaseType) {\n        return pgTweakFragmentForType(fragment, type.domainBaseType);\n      } else if (type.isPgArray) {\n        const error = new Error(\n          \"Internal graphile-build-pg error: should not attempt to tweak an array, please process array before tweaking (type: `${type.namespaceName}.${type.name}`)\"\n        );\n        if (process.env.NODE_ENV === \"test\") {\n          throw error;\n        }\n        // eslint-disable-next-line no-console\n        console.error(error);\n        return fragment;\n      } else {\n        return fragment;\n      }\n    };\n    /*\n        Determined by running:\n\n          select oid, typname, typarray, typcategory, typtype from pg_catalog.pg_type where typtype = 'b' order by oid;\n\n        We only need to add oidLookups for types that don't have the correct fallback\n      */\n    const SimpleDate = stringType(\"Date\", \"The day, does not include a time.\");\n    const SimpleDatetime = stringType(\n      \"Datetime\",\n      \"A point in time as described by the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.\"\n    );\n    const SimpleTime = stringType(\n      \"Time\",\n      \"The exact time of day, does not include the date. May or may not have a timezone offset.\"\n    );\n    const SimpleJSON = stringType(\n      pgLegacyJsonUuid ? \"Json\" : \"JSON\",\n      \"A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).\"\n    );\n    const SimpleUUID = stringType(\n      pgLegacyJsonUuid ? \"Uuid\" : \"UUID\",\n      \"A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).\"\n    );\n\n    // pgExtendedTypes might change what types we use for things\n    const JSONType = pgExtendedTypes\n      ? pgLegacyJsonUuid ? GraphQLJson : GraphQLJSON\n      : SimpleJSON;\n    const UUIDType = SimpleUUID; // GraphQLUUID\n    const DateType = SimpleDate; // GraphQLDate\n    const DateTimeType = SimpleDatetime; // GraphQLDateTime\n    const TimeType = SimpleTime; // GraphQLTime\n\n    // 'point' in PostgreSQL is a 16-byte type that's comprised of two 8-byte floats.\n    const Point = new GraphQLObjectType({\n      name: \"Point\",\n      fields: {\n        x: {\n          type: new GraphQLNonNull(GraphQLFloat),\n        },\n        y: {\n          type: new GraphQLNonNull(GraphQLFloat),\n        },\n      },\n    });\n    const PointInput = new GraphQLInputObjectType({\n      name: \"PointInput\",\n      fields: {\n        x: {\n          type: new GraphQLNonNull(GraphQLFloat),\n        },\n        y: {\n          type: new GraphQLNonNull(GraphQLFloat),\n        },\n      },\n    });\n\n    // Other plugins might want to use JSON\n    addType(JSONType);\n    addType(UUIDType);\n    addType(DateType);\n    addType(DateTimeType);\n    addType(TimeType);\n\n    const oidLookup = {\n      \"20\": stringType(\n        \"BigInt\",\n        \"A signed eight-byte integer. The upper big integer values are greater then the max value for a JavaScript number. Therefore all big integers will be output as strings and not numbers.\"\n      ), // bitint - even though this is int8, it's too big for JS int, so cast to string.\n      \"21\": GraphQLInt, // int2\n      \"23\": GraphQLInt, // int4\n      \"700\": GraphQLFloat, // float4\n      \"701\": GraphQLFloat, // float8\n      \"1700\": BigFloat, // numeric\n      \"790\": GraphQLFloat, // money\n\n      \"1186\": GQLInterval, // interval\n      \"1082\": DateType, // date\n      \"1114\": DateTimeType, // timestamp\n      \"1184\": DateTimeType, // timestamptz\n      \"1083\": TimeType, // time\n      \"1266\": TimeType, // timetz\n\n      \"114\": JSONType, // json\n      \"3802\": JSONType, // jsonb\n      \"2950\": UUIDType, // uuid\n\n      \"1560\": BitString, // bit\n      \"1562\": BitString, // varbit\n\n      \"18\": GraphQLString, // char\n      \"25\": GraphQLString, // text\n      \"1043\": GraphQLString, // varchar\n\n      \"600\": Point, // point\n    };\n    const oidInputLookup = {\n      \"1186\": GQLIntervalInput, // interval\n      \"600\": PointInput, // point\n    };\n    const identity = _ => _;\n    const jsonStringify = o => JSON.stringify(o);\n    if (pgExtendedTypes) {\n      pg2GqlMapper[114] = {\n        map: identity,\n        unmap: o => sql.value(jsonStringify(o)),\n      };\n    } else {\n      pg2GqlMapper[114] = {\n        map: jsonStringify,\n        unmap: str => sql.value(str),\n      };\n    }\n    pg2GqlMapper[3802] = pg2GqlMapper[114]; // jsonb\n\n    // interval\n    pg2GqlMapper[1186] = {\n      map: str => parseInterval(str),\n      unmap: o => {\n        const keys = [\"seconds\", \"minutes\", \"hours\", \"days\", \"months\", \"years\"];\n        const parts = [];\n        for (const key of keys) {\n          if (o[key]) {\n            parts.push(`${o[key]} ${key}`);\n          }\n        }\n        return sql.value(parts.join(\" \") || \"0 seconds\");\n      },\n    };\n\n    const parseMoney = str => {\n      const numerical = str.replace(/[^0-9.,-]/g, \"\");\n      const lastCommaIndex = numerical.lastIndexOf(\",\");\n      if (lastCommaIndex >= 0 && lastCommaIndex === numerical.length - 3) {\n        // Assume string is of the form '123.456,78'\n        return parseFloat(numerical.replace(/\\./g, \"\").replace(\",\", \".\"));\n      } else {\n        // Assume string is of the form '123,456.78'\n        return parseFloat(numerical.replace(/,/g, \"\"));\n      }\n    };\n    pg2GqlMapper[790] = {\n      map: parseMoney,\n      unmap: val => sql.fragment`(${sql.value(val)})::money`,\n    };\n\n    // point\n    pg2GqlMapper[600] = {\n      map: f => {\n        if (f[0] === \"(\" && f[f.length - 1] === \")\") {\n          const [x, y] = f\n            .substr(1, f.length - 2)\n            .split(\",\")\n            .map(f => parseFloat(f));\n          return { x, y };\n        }\n      },\n      unmap: o => sql.fragment`point(${sql.value(o.x)}, ${sql.value(o.y)})`,\n    };\n\n    // TODO: add more support for geometric types\n\n    let depth = 0;\n    const enforceGqlTypeByPgType = type => {\n      depth++;\n      if (depth > 50) {\n        throw new Error(\"Type enforcement went too deep - infinite loop?\");\n      }\n      try {\n        return reallyEnforceGqlTypeByPgType(type);\n      } catch (e) {\n        const error = new Error(\n          `Error occurred when processing database type '${\n            type.namespaceName\n          }.${type.name}' (type=${type.type}):\\n${indent(e.message)}`\n        );\n        // $FlowFixMe\n        error.originalError = e;\n        throw error;\n      } finally {\n        depth--;\n      }\n    };\n    const reallyEnforceGqlTypeByPgType = type => {\n      if (!type.id) {\n        throw new Error(\n          `Invalid argument to enforceGqlTypeByPgType - expected a full type, received '${type}'`\n        );\n      }\n      // Explicit overrides\n      if (!gqlTypeByTypeId[type.id]) {\n        const gqlType = oidLookup[type.id];\n        if (gqlType) {\n          gqlTypeByTypeId[type.id] = gqlType;\n        }\n      }\n      if (!gqlInputTypeByTypeId[type.id]) {\n        const gqlInputType = oidInputLookup[type.id];\n        if (gqlInputType) {\n          gqlInputTypeByTypeId[type.id] = gqlInputType;\n        }\n      }\n      // Enums\n      if (!gqlTypeByTypeId[type.id] && type.type === \"e\") {\n        gqlTypeByTypeId[type.id] = new GraphQLEnumType({\n          name: inflection.enumType(type),\n          description: type.description,\n          values: type.enumVariants.reduce((memo, value) => {\n            memo[inflection.enumName(value)] = {\n              value: value,\n            };\n            return memo;\n          }, {}),\n        });\n      }\n      // Ranges\n      if (!gqlTypeByTypeId[type.id] && type.type === \"r\") {\n        const subtype =\n          introspectionResultsByKind.typeById[type.rangeSubTypeId];\n        const gqlRangeSubType = enforceGqlTypeByPgType(subtype);\n        if (!gqlRangeSubType) {\n          throw new Error(\"Range of unsupported\");\n        }\n        let Range = getTypeByName(inflection.rangeType(gqlRangeSubType.name));\n        let RangeInput;\n        if (!Range) {\n          const RangeBound = new GraphQLObjectType({\n            name: inflection.rangeBoundType(gqlRangeSubType.name),\n            description:\n              \"The value at one end of a range. A range can either include this value, or not.\",\n            fields: {\n              value: {\n                description: \"The value at one end of our range.\",\n                type: new GraphQLNonNull(gqlRangeSubType),\n              },\n              inclusive: {\n                description:\n                  \"Whether or not the value of this bound is included in the range.\",\n                type: new GraphQLNonNull(GraphQLBoolean),\n              },\n            },\n          });\n          const RangeBoundInput = new GraphQLInputObjectType({\n            name: inflection.inputType(RangeBound.name),\n            description:\n              \"The value at one end of a range. A range can either include this value, or not.\",\n            fields: {\n              value: {\n                description: \"The value at one end of our range.\",\n                type: new GraphQLNonNull(gqlRangeSubType),\n              },\n              inclusive: {\n                description:\n                  \"Whether or not the value of this bound is included in the range.\",\n                type: new GraphQLNonNull(GraphQLBoolean),\n              },\n            },\n          });\n          Range = new GraphQLObjectType({\n            name: inflection.rangeType(gqlRangeSubType.name),\n            description: `A range of \\`${gqlRangeSubType.name}\\`.`,\n            fields: {\n              start: {\n                description: \"The starting bound of our range.\",\n                type: RangeBound,\n              },\n              end: {\n                description: \"The ending bound of our range.\",\n                type: RangeBound,\n              },\n            },\n          });\n          RangeInput = new GraphQLInputObjectType({\n            name: inflection.inputType(Range.name),\n            description: `A range of \\`${gqlRangeSubType.name}\\`.`,\n            fields: {\n              start: {\n                description: \"The starting bound of our range.\",\n                type: RangeBoundInput,\n              },\n              end: {\n                description: \"The ending bound of our range.\",\n                type: RangeBoundInput,\n              },\n            },\n          });\n          addType(Range);\n          addType(RangeInput);\n        } else {\n          RangeInput = getTypeByName(inflection.inputType(Range.name));\n        }\n        gqlTypeByTypeId[type.id] = Range;\n        gqlInputTypeByTypeId[type.id] = RangeInput;\n        pg2GqlMapper[type.id] = {\n          map: pgRange => {\n            const parsed = pgRangeParser.parse(pgRange);\n            // Since the value we will get from `parsed.(start|end).value` is a\n            // string but our code will expect it to be the value after `pg`\n            // parsed it, we pass through to `pg-types` for parsing.\n            const pgParse =\n              rawTypes.indexOf(parseInt(subtype.id, 10)) >= 0\n                ? identity\n                : pgTypes.getTypeParser(subtype.id);\n            const { start, end } = parsed;\n            return {\n              start: start\n                ? {\n                    value: pg2gql(pgParse(start.value), subtype),\n                    inclusive: start.inclusive,\n                  }\n                : null,\n              end: end\n                ? {\n                    value: pg2gql(pgParse(end.value), subtype),\n                    inclusive: end.inclusive,\n                  }\n                : null,\n            };\n          },\n          unmap: ({ start, end }) => {\n            // Ref: https://www.postgresql.org/docs/9.6/static/rangetypes.html#RANGETYPES-CONSTRUCT\n            const lower = (start && gql2pg(start.value, subtype)) || sql.null;\n            const upper = (end && gql2pg(end.value, subtype)) || sql.null;\n            const lowerInclusive = start && !start.inclusive ? \"(\" : \"[\";\n            const upperInclusive = end && !end.inclusive ? \")\" : \"]\";\n            return sql.fragment`${sql.identifier(\n              type.namespaceName,\n              type.name\n            )}(${lower}, ${upper}, ${sql.literal(\n              lowerInclusive + upperInclusive\n            )})`;\n          },\n        };\n      }\n\n      // Domains\n      if (\n        !gqlTypeByTypeId[type.id] &&\n        type.type === \"d\" &&\n        type.domainBaseTypeId\n      ) {\n        const baseType = enforceGqlTypeByPgType(type.domainBaseType);\n        const baseInputType = gqlInputTypeByTypeId[type.domainBaseTypeId];\n        // Hack stolen from: https://github.com/graphile/postgraphile/blob/ade728ed8f8e3ecdc5fdad7d770c67aa573578eb/src/graphql/schema/type/aliasGqlType.ts#L16\n        gqlTypeByTypeId[type.id] = Object.assign(Object.create(baseType), {\n          name: inflection.domainType(type),\n          description: type.description,\n        });\n        if (baseInputType && baseInputType !== baseType) {\n          gqlInputTypeByTypeId[type.id] = Object.assign(\n            Object.create(baseInputType),\n            {\n              name: inflection.inputType(gqlTypeByTypeId[type.id]),\n              description: type.description,\n            }\n          );\n        }\n      }\n\n      // Fall back to categories\n      if (!gqlTypeByTypeId[type.id]) {\n        const gen = categoryLookup[type.category];\n        if (gen) {\n          gqlTypeByTypeId[type.id] = gen(type);\n        }\n      }\n\n      // Nothing else worked; pass through as string!\n      if (!gqlTypeByTypeId[type.id]) {\n        // XXX: consider using stringType(upperFirst(camelCase(`fallback_${type.name}`)), type.description)?\n        gqlTypeByTypeId[type.id] = GraphQLString;\n      }\n      // Now for input types, fall back to output types if possible\n      if (!gqlInputTypeByTypeId[type.id]) {\n        if (isInputType(gqlTypeByTypeId[type.id])) {\n          gqlInputTypeByTypeId[type.id] = gqlTypeByTypeId[type.id];\n        }\n      }\n      addType(getNamedType(gqlTypeByTypeId[type.id]));\n      return gqlTypeByTypeId[type.id];\n    };\n\n    function getGqlTypeByTypeId(typeId) {\n      if (!gqlInputTypeByTypeIdGenerator[typeId]) {\n        const type = introspectionResultsByKind.type.find(t => t.id === typeId);\n        return enforceGqlTypeByPgType(type);\n      }\n      if (!gqlTypeByTypeId[typeId]) {\n        const type = introspectionResultsByKind.type.find(t => t.id === typeId);\n        if (!type) {\n          throw new Error(\n            `Type '${typeId}' not present in introspection results`\n          );\n        }\n        const gen = gqlTypeByTypeIdGenerator[type.id];\n        if (gen) {\n          const set = Type => {\n            gqlTypeByTypeId[type.id] = Type;\n          };\n          const result = gen(set);\n          if (result) {\n            if (\n              gqlTypeByTypeId[type.id] &&\n              gqlTypeByTypeId[type.id] !== result\n            ) {\n              throw new Error(\n                `Callback and return types differ when defining type for '${\n                  type.id\n                }'`\n              );\n            }\n            gqlTypeByTypeId[type.id] = result;\n          }\n        }\n      }\n      return gqlTypeByTypeId[typeId];\n    }\n    function getGqlInputTypeByTypeId(typeId) {\n      if (!gqlInputTypeByTypeIdGenerator[typeId]) {\n        const type = introspectionResultsByKind.type.find(t => t.id === typeId);\n        enforceGqlTypeByPgType(type);\n        return gqlInputTypeByTypeId[typeId];\n      }\n      if (!gqlInputTypeByTypeId[typeId]) {\n        const type = introspectionResultsByKind.type.find(t => t.id === typeId);\n        getGqlTypeByTypeId(typeId);\n        if (!type) {\n          throw new Error(\n            `Type '${typeId}' not present in introspection results`\n          );\n        }\n        const gen = gqlInputTypeByTypeIdGenerator[type.id];\n        if (gen) {\n          const set = Type => {\n            gqlInputTypeByTypeId[type.id] = Type;\n          };\n          const result = gen(set);\n          if (result) {\n            if (\n              gqlInputTypeByTypeId[type.id] &&\n              gqlInputTypeByTypeId[type.id] !== result\n            ) {\n              throw new Error(\n                `Callback and return types differ when defining type for '${\n                  type.id\n                }'`\n              );\n            }\n            gqlInputTypeByTypeId[type.id] = result;\n          }\n        }\n      }\n      return gqlInputTypeByTypeId[typeId];\n    }\n\n    function registerGqlTypeByTypeId(typeId, gen, yieldToExisting = false) {\n      if (gqlTypeByTypeIdGenerator[typeId]) {\n        if (yieldToExisting) {\n          return;\n        }\n        throw new Error(\n          `There's already a type generator registered for '${typeId}'`\n        );\n      }\n      gqlTypeByTypeIdGenerator[typeId] = gen;\n    }\n    function registerGqlInputTypeByTypeId(\n      typeId,\n      gen,\n      yieldToExisting = false\n    ) {\n      if (gqlInputTypeByTypeIdGenerator[typeId]) {\n        if (yieldToExisting) {\n          return;\n        }\n        throw new Error(\n          `There's already an input type generator registered for '${typeId}'`\n        );\n      }\n      gqlInputTypeByTypeIdGenerator[typeId] = gen;\n    }\n\n    return build.extend(build, {\n      pgRegisterGqlTypeByTypeId: registerGqlTypeByTypeId,\n      pgRegisterGqlInputTypeByTypeId: registerGqlInputTypeByTypeId,\n      pgGetGqlTypeByTypeId: getGqlTypeByTypeId,\n      pgGetGqlInputTypeByTypeId: getGqlInputTypeByTypeId,\n      pg2GqlMapper,\n      pg2gql,\n      gql2pg,\n      pgTweakFragmentForType,\n      pgTweaksByTypeId,\n    });\n  });\n}: Plugin);\n"]}