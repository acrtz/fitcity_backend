"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeNewBuild;

var _graphql = require("graphql");

var graphql = _interopRequireWildcard(_graphql);

var _graphqlParseResolveInfo = require("graphql-parse-resolve-info");

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

var _pluralize = require("pluralize");

var _pluralize2 = _interopRequireDefault(_pluralize);

var _lruCache = require("lru-cache");

var _lruCache2 = _interopRequireDefault(_lruCache);

var _utils = require("./utils");

var _extend = require("./extend");

var _extend2 = _interopRequireDefault(_extend);

var _crypto = require("crypto");

var _package = require("../package.json");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const isString = str => typeof str === "string";

const isDev = ["test", "development"].indexOf(process.env.NODE_ENV) >= 0;
const debug = (0, _debug2.default)("graphile-build");
const debugWarn = (0, _debug2.default)("graphile-build:warn");

/*
 * This should be more than enough for normal usage. If you come under a
 * sophisticated attack then the attacker can empty this of useful values (with
 * a lot of work) but because we use SHA1 hashes under the covers the aliases
 * will still be consistent even after the LRU cache is exhausted. And SHA1 can
 * produce half a million hashes per second on my machine, the LRU only gives
 * us a 10x speedup!
 */
const hashCache = (0, _lruCache2.default)(100000);

/*
 * This function must never return a string longer than 56 characters.
 *
 * This function must only output alphanumeric and underscore characters.
 *
 * Collisions in SHA1 aren't problematic here (for us; they will be problematic
 * for the user deliberately causing them, but that's their own fault!), so
 * we'll happily take the performance boost over SHA256.
 */
function hashFieldAlias(str) {
  const precomputed = hashCache.get(str);
  if (precomputed) return precomputed;
  const hash = (0, _crypto.createHash)("sha1").update(str).digest("hex");
  hashCache.set(str, hash);
  return hash;
}

/*
 * This function may be replaced at any time, but all versions of it will
 * always return a representation of `alias` (a valid GraphQL identifier)
 * that:
 *
 *   1. won't conflict with normal GraphQL field names
 *   2. won't be over 60 characters long (allows for systems with alias length limits, such as PG)
 *   3. will give the same value when called multiple times within the same GraphQL query
 *   4. matches the regex /^[@!-_A-Za-z0-9]+$/
 *   5. will not be prefixed with `__` (as that will conflict with other Graphile internals)
 *
 * It does not guarantee that this alias will be human readable!
 */
function getSafeAliasFromAlias(alias) {
  if (alias.length <= 60 && !alias.startsWith("@")) {
    // Use the `@` to prevent conflicting with normal GraphQL field names, but otherwise let it through verbatim.
    return `@${alias}`;
  } else if (alias.length > 1024) {
    throw new Error(`GraphQL alias '${alias}' is too long, use shorter aliases (max length 1024).`);
  } else {
    return `@@${hashFieldAlias(alias)}`;
  }
}

/*
 * This provides a "safe" version of the alias from ResolveInfo, guaranteed to
 * never be longer than 60 characters. This makes it suitable as a PostgreSQL
 * identifier.
 */
function getSafeAliasFromResolveInfo(resolveInfo) {
  const alias = (0, _graphqlParseResolveInfo.getAliasFromResolveInfo)(resolveInfo);
  return getSafeAliasFromAlias(alias);
}

function getNameFromType(Type) {
  if (Type instanceof GraphQLSchema) {
    return "schema";
  } else {
    return Type.name;
  }
}

const {
  GraphQLSchema,
  GraphQLObjectType,
  GraphQLInputObjectType,
  GraphQLEnumType,
  getNamedType,
  isCompositeType,
  isAbstractType
} = graphql;

const mergeData = (data, gen, ReturnType, arg) => {
  const results = ensureArray(gen(arg, ReturnType, data));
  if (!results) {
    return;
  }
  for (const result of results) {
    for (const k of Object.keys(result)) {
      data[k] = data[k] || [];
      const value = result[k];
      const newData = ensureArray(value);
      if (newData) {
        data[k].push(...newData);
      }
    }
  }
};

const knownTypes = [GraphQLSchema, GraphQLObjectType, GraphQLInputObjectType, GraphQLEnumType];
const knownTypeNames = knownTypes.map(k => k.name);

function ensureArray(val) {
  if (val == null) {
    return;
  } else if (Array.isArray(val)) {
    return val;
  } else {
    return [val];
  }
}

// eslint-disable-next-line no-unused-vars
let ensureName = fn => {};
if (["development", "test"].indexOf(process.env.NODE_ENV) >= 0) {
  ensureName = fn => {
    if (isDev && !fn.displayName && !fn.name && debug.enabled) {
      // eslint-disable-next-line no-console
      console.trace("WARNING: you've added a function with no name as an argDataGenerator, doing so may make debugging more challenging");
    }
  };
}

function makeNewBuild(builder) {
  const allTypes = {};

  // Every object type gets fieldData associated with each of its
  // fields.

  // When a field is defined, it may add to this field data.

  // When something resolves referencing this type, the resolver may
  // request the fieldData, e.g. to perform optimisations.

  // fieldData is an object whose keys are the fields on this
  // GraphQLObjectType and whose values are an object (whose keys are
  // arbitrary namespaced keys and whose values are arrays of
  // information of this kind)
  const fieldDataGeneratorsByFieldNameByType = new Map();
  const fieldArgDataGeneratorsByFieldNameByType = new Map();

  return {
    graphileBuildVersion: _package.version,
    graphql,
    parseResolveInfo: _graphqlParseResolveInfo.parseResolveInfo,
    simplifyParsedResolveInfoFragmentWithType: _graphqlParseResolveInfo.simplifyParsedResolveInfoFragmentWithType,
    getSafeAliasFromAlias,
    getAliasFromResolveInfo: getSafeAliasFromResolveInfo, // DEPRECATED: do not use this!
    getSafeAliasFromResolveInfo,
    resolveAlias(data, _args, _context, resolveInfo) {
      const alias = getSafeAliasFromResolveInfo(resolveInfo);
      return data[alias];
    },
    addType(type) {
      if (!type.name) {
        throw new Error(`addType must only be called with named types, try using require('graphql').getNamedType`);
      }
      if (allTypes[type.name] && allTypes[type.name] !== type) {
        throw new Error(`There's already a type with the name: ${type.name}`);
      }
      allTypes[type.name] = type;
    },
    getTypeByName(typeName) {
      return allTypes[typeName];
    },
    extend: _extend2.default,
    newWithHooks(Type, spec, inScope, returnNullOnInvalid = false) {
      const scope = inScope || {};
      if (!inScope) {
        // eslint-disable-next-line no-console
        console.warn(`No scope was provided to new ${Type.name}[name=${spec.name}], it's highly recommended that you add a scope so other hooks can easily reference your object - please check usage of 'newWithHooks'. To mute this message, just pass an empty object.`);
      }
      if (!Type) {
        throw new Error("No type specified!");
      }
      if (!this.newWithHooks || !Object.isFrozen(this)) {
        throw new Error("Please do not generate the schema during the build building phase, use 'init' instead");
      }
      const fieldDataGeneratorsByFieldName = {};
      const fieldArgDataGeneratorsByFieldName = {};
      let newSpec = spec;
      if (knownTypes.indexOf(Type) === -1 && knownTypeNames.indexOf(Type.name) >= 0) {
        throw new Error(`GraphQL conflict for '${Type.name}' detected! Multiple versions of graphql exist in your node_modules?`);
      }
      if (Type === GraphQLSchema) {
        newSpec = builder.applyHooks(this, "GraphQLSchema", newSpec, {
          type: "GraphQLSchema",
          scope
        });
      } else if (Type === GraphQLObjectType) {
        const addDataGeneratorForField = (fieldName, fn) => {
          fn.displayName = fn.displayName || `${getNameFromType(Self)}:${fieldName}[${fn.name || "anonymous"}]`;
          fieldDataGeneratorsByFieldName[fieldName] = fieldDataGeneratorsByFieldName[fieldName] || [];
          fieldDataGeneratorsByFieldName[fieldName].push(fn);
        };
        const recurseDataGeneratorsForField = fieldName => {
          const fn = (parsedResolveInfoFragment, ReturnType, ...rest) => {
            const { args } = parsedResolveInfoFragment;
            const { fields } = this.simplifyParsedResolveInfoFragmentWithType(parsedResolveInfoFragment, ReturnType);
            const results = [];
            const StrippedType = getNamedType(ReturnType);
            const fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(StrippedType);
            const argDataGeneratorsForSelfByFieldName = fieldArgDataGeneratorsByFieldNameByType.get(Self);
            if (argDataGeneratorsForSelfByFieldName) {
              const argDataGenerators = argDataGeneratorsForSelfByFieldName[fieldName];
              for (const gen of argDataGenerators) {
                const local = ensureArray(gen(args, ReturnType, ...rest));
                if (local) {
                  results.push(...local);
                }
              }
            }
            if (fieldDataGeneratorsByFieldName && isCompositeType(StrippedType) && !isAbstractType(StrippedType)) {
              const typeFields = StrippedType.getFields();
              for (const alias of Object.keys(fields)) {
                const field = fields[alias];
                // Run generators with `field` as the `parsedResolveInfoFragment`, pushing results to `results`
                const gens = fieldDataGeneratorsByFieldName[field.name];
                if (gens) {
                  for (const gen of gens) {
                    const local = ensureArray(gen(field, typeFields[field.name].type, ...rest));
                    if (local) {
                      results.push(...local);
                    }
                  }
                }
              }
            }
            return results;
          };
          fn.displayName = `recurseDataGeneratorsForField(${getNameFromType(Self)}:${fieldName})`;
          addDataGeneratorForField(fieldName, fn);
          // get type from field, get
        };

        const commonContext = {
          type: "GraphQLObjectType",
          scope
        };
        newSpec = builder.applyHooks(this, "GraphQLObjectType", newSpec, Object.assign({}, commonContext, {
          addDataGeneratorForField,
          recurseDataGeneratorsForField
        }), `|${newSpec.name}`);

        const rawSpec = newSpec;
        newSpec = Object.assign({}, newSpec, {
          interfaces: () => {
            const interfacesContext = Object.assign({}, commonContext, {
              Self,
              GraphQLObjectType: rawSpec
            });
            let rawInterfaces = rawSpec.interfaces || [];
            if (typeof rawInterfaces === "function") {
              rawInterfaces = rawInterfaces(interfacesContext);
            }
            return builder.applyHooks(this, "GraphQLObjectType:interfaces", rawInterfaces, interfacesContext, `|${getNameFromType(Self)}`);
          },
          fields: () => {
            const processedFields = [];
            const fieldsContext = Object.assign({}, commonContext, {
              addDataGeneratorForField,
              recurseDataGeneratorsForField,
              Self,
              GraphQLObjectType: rawSpec,
              fieldWithHooks: (fieldName, spec, fieldScope) => {
                if (!isString(fieldName)) {
                  throw new Error("It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.");
                }
                if (!fieldScope) {
                  throw new Error("All calls to `fieldWithHooks` must specify a `fieldScope` " + "argument that gives additional context about the field so " + "that further plugins may more easily understand the field. " + "Keys within this object should contain the phrase 'field' " + "since they will be merged into the parent objects scope and " + "are not allowed to clash. If you really have no additional " + "information to give, please just pass `{}`.");
                }

                let argDataGenerators = [];
                fieldArgDataGeneratorsByFieldName[fieldName] = argDataGenerators;

                let newSpec = spec;
                let context = Object.assign({}, commonContext, {
                  Self,
                  addDataGenerator(fn) {
                    return addDataGeneratorForField(fieldName, fn);
                  },
                  addArgDataGenerator(fn) {
                    ensureName(fn);
                    argDataGenerators.push(fn);
                  },
                  getDataFromParsedResolveInfoFragment: (parsedResolveInfoFragment, ReturnType) => {
                    const Type = getNamedType(ReturnType);
                    const data = {};

                    const {
                      fields,
                      args
                    } = this.simplifyParsedResolveInfoFragmentWithType(parsedResolveInfoFragment, ReturnType);

                    // Args -> argDataGenerators
                    for (const gen of argDataGenerators) {
                      try {
                        mergeData(data, gen, ReturnType, args);
                      } catch (e) {
                        debug("Failed to execute argDataGenerator '%s' on %s of %s", gen.displayName || gen.name || "anonymous", fieldName, getNameFromType(Self));
                        throw e;
                      }
                    }

                    // finalSpec.type -> fieldData
                    if (!finalSpec) {
                      throw new Error("It's too early to call this! Call from within resolve");
                    }
                    const fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(Type);
                    if (fieldDataGeneratorsByFieldName && isCompositeType(Type) && !isAbstractType(Type)) {
                      const typeFields = Type.getFields();
                      for (const alias of Object.keys(fields)) {
                        const field = fields[alias];
                        const gens = fieldDataGeneratorsByFieldName[field.name];
                        if (gens) {
                          const FieldReturnType = typeFields[field.name].type;
                          for (const gen of gens) {
                            mergeData(data, gen, FieldReturnType, field);
                          }
                        }
                      }
                    }
                    return data;
                  },
                  scope: (0, _extend2.default)((0, _extend2.default)(scope, {
                    fieldName
                  }, `Within context for GraphQLObjectType '${rawSpec.name}'`), fieldScope, `Extending scope for field '${fieldName}' within context for GraphQLObjectType '${rawSpec.name}'`)
                });
                if (typeof newSpec === "function") {
                  newSpec = newSpec(context);
                }
                newSpec = builder.applyHooks(this, "GraphQLObjectType:fields:field", newSpec, context, `|${getNameFromType(Self)}.fields.${fieldName}`);
                newSpec.args = newSpec.args || {};
                newSpec = Object.assign({}, newSpec, {
                  args: builder.applyHooks(this, "GraphQLObjectType:fields:field:args", newSpec.args, Object.assign({}, context, {
                    field: newSpec,
                    returnType: newSpec.type
                  }), `|${getNameFromType(Self)}.fields.${fieldName}`)
                });
                const finalSpec = newSpec;
                processedFields.push(finalSpec);
                return finalSpec;
              }
            });
            let rawFields = rawSpec.fields || {};
            if (typeof rawFields === "function") {
              rawFields = rawFields(fieldsContext);
            }
            const fieldsSpec = builder.applyHooks(this, "GraphQLObjectType:fields", rawFields, fieldsContext, `|${rawSpec.name}`);
            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.
            for (const fieldName in fieldsSpec) {
              const fieldSpec = fieldsSpec[fieldName];
              if (processedFields.indexOf(fieldSpec) < 0) {
                // We've not processed this yet; process it now!
                fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(fieldName, fieldSpec, {
                  autoField: true // We don't have any additional information
                });
              }
            }
            return fieldsSpec;
          }
        });
      } else if (Type === GraphQLInputObjectType) {
        const commonContext = {
          type: "GraphQLInputObjectType",
          scope
        };
        newSpec = builder.applyHooks(this, "GraphQLInputObjectType", newSpec, commonContext, `|${newSpec.name}`);
        newSpec.fields = newSpec.fields || {};

        const rawSpec = newSpec;
        newSpec = Object.assign({}, newSpec, {
          fields: () => {
            const processedFields = [];
            const fieldsContext = Object.assign({}, commonContext, {
              Self,
              GraphQLInputObjectType: rawSpec,
              fieldWithHooks: (fieldName, spec, fieldScope = {}) => {
                if (!isString(fieldName)) {
                  throw new Error("It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.");
                }
                let context = Object.assign({}, commonContext, {
                  Self,
                  scope: (0, _extend2.default)((0, _extend2.default)(scope, {
                    fieldName
                  }, `Within context for GraphQLInputObjectType '${rawSpec.name}'`), fieldScope, `Extending scope for field '${fieldName}' within context for GraphQLInputObjectType '${rawSpec.name}'`)
                });
                let newSpec = spec;
                if (typeof newSpec === "function") {
                  newSpec = newSpec(context);
                }
                newSpec = builder.applyHooks(this, "GraphQLInputObjectType:fields:field", newSpec, context, `|${getNameFromType(Self)}.fields.${fieldName}`);
                const finalSpec = newSpec;
                processedFields.push(finalSpec);
                return finalSpec;
              }
            });
            let rawFields = rawSpec.fields;
            if (typeof rawFields === "function") {
              rawFields = rawFields(fieldsContext);
            }
            const fieldsSpec = builder.applyHooks(this, "GraphQLInputObjectType:fields", rawFields, fieldsContext, `|${getNameFromType(Self)}`);
            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.
            for (const fieldName in fieldsSpec) {
              const fieldSpec = fieldsSpec[fieldName];
              if (processedFields.indexOf(fieldSpec) < 0) {
                // We've not processed this yet; process it now!
                fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(fieldName, fieldSpec, {
                  autoField: true // We don't have any additional information
                });
              }
            }
            return fieldsSpec;
          }
        });
      } else if (Type === GraphQLEnumType) {
        const commonContext = {
          type: "GraphQLEnumType",
          scope
        };
        newSpec = builder.applyHooks(this, "GraphQLEnumType", newSpec, commonContext, `|${newSpec.name}`);

        newSpec.values = builder.applyHooks(this, "GraphQLEnumType:values", newSpec.values, commonContext, `|${newSpec.name}`);
        const values = newSpec.values;
        newSpec.values = Object.keys(values).reduce((memo, valueKey) => {
          const value = values[valueKey];
          const newValue = builder.applyHooks(this, "GraphQLEnumType:values:value", value, commonContext, `|${newSpec.name}|${valueKey}`);
          memo[valueKey] = newValue;
          return memo;
        }, {});
      }
      const finalSpec = newSpec;

      const Self = new Type(finalSpec);
      if (!(Self instanceof GraphQLSchema) && returnNullOnInvalid) {
        try {
          if (isCompositeType(Self) && !isAbstractType(Self)) {
            Self.getFields();
          }
        } catch (e) {
          // This is the error we're expecting to handle:
          // https://github.com/graphql/graphql-js/blob/831598ba76f015078ecb6c5c1fbaf133302f3f8e/src/type/definition.js#L526-L531
          const isProbablyAnEmptyObjectError = !!e.message.match(/function which returns such an object/);
          if (!isProbablyAnEmptyObjectError) {
            // XXX: Improve this
            // eslint-disable-next-line no-console
            console.warn(`An error occurred, it might be okay but it doesn't look like the error we were expecting... run with envvar 'DEBUG="graphile-build:warn"' to view the error`);
            debugWarn(e);
          }
          return null;
        }
      }

      if (finalSpec.name) {
        if (allTypes[finalSpec.name]) {
          throw new Error(`Type '${finalSpec.name}' has already been registered!`);
        }
        allTypes[finalSpec.name] = Self;
      }
      fieldDataGeneratorsByFieldNameByType.set(Self, fieldDataGeneratorsByFieldName);
      fieldArgDataGeneratorsByFieldNameByType.set(Self, fieldArgDataGeneratorsByFieldName);
      return Self;
    },
    fieldDataGeneratorsByType: fieldDataGeneratorsByFieldNameByType, // @deprecated
    fieldDataGeneratorsByFieldNameByType,
    fieldArgDataGeneratorsByFieldNameByType,
    inflection: {
      pluralize: _pluralize2.default,
      singularize: _pluralize2.default.singular,
      upperCamelCase: _utils.upperCamelCase,
      camelCase: _utils.camelCase,
      constantCase: _utils.constantCase
    }
  };
}
//# sourceMappingURL=makeNewBuild.js.map